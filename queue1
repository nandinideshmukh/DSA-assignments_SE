#include <iostream>
using namespace std;

class node {
public:
    int data;
    node* next;

    node() : data(0), next(nullptr) {}
    node(int val) : data(val), next(nullptr) {}
};

class Queue {
    int size;       
    int count;      
    node* front;    
    node* rear;     

public:
    Queue() : size(10), count(0), front(nullptr), rear(nullptr) {}

    bool isEmpty() {
        return (front == nullptr);
    }

    bool isFull() {
        return (count == size);
    }

    void enqueue(int val) {
        if (isFull()) {
            cout << "\nQueue is full!" << endl;
            return;
        }

        node* n = new node(val);

        if (isEmpty()) {
            front = rear = n;  
        } else {
            rear->next = n;
            rear = n;
        }

        count++;                
        cout << "Enqueued: " << val << " | Queue size: " << count << endl;
    }

    void dequeue() {
        if (isEmpty()) {
            cout << "\nQueue underflow (empty queue)" << endl;
            return;
        }

        node* todel = front;
        front = front->next;    

        if (front == nullptr) { 
            rear = nullptr;
        }

        delete todel;          
        count--;                
        cout << "Dequeued | Queue size: " << count << endl;
    }

    int getFront() {
        if (isEmpty()) {
            cout << "\nQueue is empty!";
            return -1;
        }
        return front->data;
    }

    int getRear() {
        if (isEmpty()) {
            cout << "\nQueue is empty!";
            return -1;
        }
        return rear->data;
    }
};

int main() {
    Queue q;

    for (int i = 0; i < 10; i++) {
        q.enqueue(i + 1);
    }

    q.enqueue(11);

    cout << "Front element: " << q.getFront() << endl;
    cout << "Rear element: " << q.getRear() << endl;

    while (!q.isEmpty()) {
        q.dequeue();
    }

    q.dequeue();

    return 0;
}
